name: üî• Chaos Engineering Suite

on:
  schedule:
    - cron: '0 3 * * 0'  # Weekly on Sunday at 3 AM UTC
  workflow_dispatch:
    inputs:
      experiment_type:
        description: 'Type of chaos experiment'
        required: true
        type: choice
        options:
          - all
          - network
          - compute
          - storage
          - dependency
          - latency
      target_environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - canary
        default: staging
      duration_minutes:
        description: 'Experiment duration (minutes)'
        required: false
        default: '15'
        type: string
      blast_radius:
        description: 'Blast radius percentage'
        required: false
        default: '25'
        type: string
      abort_on_failure:
        description: 'Abort if steady state violated'
        type: boolean
        default: true
      dry_run:
        description: 'Dry run (simulate only)'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  CHAOS_DIR: '.chaos'
  RESULTS_DIR: '.chaos/results'

jobs:
  # ============================================================
  # JOB 1: Pre-Flight Checks
  # ============================================================
  preflight:
    name: üõ´ Pre-Flight Checks
    runs-on: ubuntu-latest
    outputs:
      experiment_id: ${{ steps.preflight.outputs.experiment_id }}
      can_proceed: ${{ steps.preflight.outputs.can_proceed }}
      steady_state: ${{ steps.preflight.outputs.steady_state }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: üõ´ Run pre-flight checks
        id: preflight
        run: |
          echo "üõ´ Chaos Engineering Pre-Flight Checks"
          echo "======================================="
          echo ""

          EXPERIMENT_ID="chaos-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
          echo "Experiment ID: $EXPERIMENT_ID"

          # Check environment
          TARGET_ENV="${{ github.event.inputs.target_environment || 'staging' }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo ""
          echo "üìã Configuration:"
          echo "  Environment: $TARGET_ENV"
          echo "  Dry Run: $DRY_RUN"
          echo "  Duration: ${{ github.event.inputs.duration_minutes || '15' }} minutes"
          echo "  Blast Radius: ${{ github.event.inputs.blast_radius || '25' }}%"
          echo ""

          # Safety checks
          CAN_PROCEED="true"
          WARNINGS=""

          # Check 1: Not production
          if [ "$TARGET_ENV" = "production" ]; then
            echo "‚ùå BLOCKED: Cannot run chaos experiments in production"
            CAN_PROCEED="false"
          fi

          # Check 2: Business hours (warn only)
          HOUR=$(date -u +%H)
          if [ "$HOUR" -ge 9 ] && [ "$HOUR" -le 17 ]; then
            echo "‚ö†Ô∏è WARNING: Running during business hours (UTC)"
            WARNINGS="$WARNINGS,business_hours"
          fi

          # Check 3: Recent incidents
          echo "Checking for recent incidents..."
          # Simulate incident check
          RECENT_INCIDENTS=0
          if [ $RECENT_INCIDENTS -gt 0 ]; then
            echo "‚ö†Ô∏è WARNING: $RECENT_INCIDENTS recent incidents detected"
            WARNINGS="$WARNINGS,recent_incidents"
          fi

          # Capture steady state
          echo ""
          echo "üìä Capturing steady state baseline..."

          # Simulated steady state metrics
          STEADY_STATE=$(cat << 'EOF'
          {
            "timestamp": "",
            "metrics": {
              "error_rate_pct": 0.5,
              "latency_p99_ms": 150,
              "availability_pct": 99.95,
              "cpu_usage_pct": 45,
              "memory_usage_pct": 62,
              "active_connections": 1250
            },
            "thresholds": {
              "max_error_rate_pct": 5,
              "max_latency_p99_ms": 500,
              "min_availability_pct": 99,
              "max_cpu_usage_pct": 85,
              "max_memory_usage_pct": 90
            }
          }
          EOF
          )

          # Add timestamp
          STEADY_STATE=$(echo "$STEADY_STATE" | jq --arg ts "$(date -Iseconds)" '.timestamp = $ts')

          echo "Steady state captured:"
          echo "$STEADY_STATE" | jq '.metrics'

          if [ "$CAN_PROCEED" = "true" ]; then
            echo ""
            echo "‚úÖ Pre-flight checks passed"
          else
            echo ""
            echo "‚ùå Pre-flight checks failed"
          fi

          echo "experiment_id=$EXPERIMENT_ID" >> $GITHUB_OUTPUT
          echo "can_proceed=$CAN_PROCEED" >> $GITHUB_OUTPUT
          echo "steady_state=$(echo $STEADY_STATE | jq -c '.')" >> $GITHUB_OUTPUT

      - name: üì¶ Save pre-flight data
        run: |
          mkdir -p /tmp/chaos
          echo '${{ steps.preflight.outputs.steady_state }}' > /tmp/chaos/steady-state.json

      - name: üì¶ Upload pre-flight data
        uses: actions/upload-artifact@v4
        with:
          name: preflight-data
          path: /tmp/chaos/

  # ============================================================
  # JOB 2: Network Chaos
  # ============================================================
  network-chaos:
    name: üåê Network Chaos
    needs: preflight
    runs-on: ubuntu-latest
    if: needs.preflight.outputs.can_proceed == 'true' && contains(fromJSON('["all", "network"]'), github.event.inputs.experiment_type || 'all')
    outputs:
      results: ${{ steps.experiment.outputs.results }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: üåê Run network chaos experiments
        id: experiment
        run: |
          echo "üåê Network Chaos Experiments"
          echo "============================"
          echo ""

          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"
          DURATION="${{ github.event.inputs.duration_minutes || '15' }}"
          BLAST_RADIUS="${{ github.event.inputs.blast_radius || '25' }}"

          RESULTS_FILE="/tmp/network-chaos-results.json"

          cat > "$RESULTS_FILE" << EOF
          {
            "category": "network",
            "experiment_id": "${{ needs.preflight.outputs.experiment_id }}",
            "start_time": "$(date -Iseconds)",
            "dry_run": $DRY_RUN,
            "experiments": []
          }
          EOF

          # Network chaos experiments
          declare -A EXPERIMENTS=(
            ["packet_loss"]="Packet Loss (10%)"
            ["latency_injection"]="Latency Injection (+200ms)"
            ["bandwidth_limit"]="Bandwidth Limit (1Mbps)"
            ["dns_failure"]="DNS Resolution Failure"
            ["connection_reset"]="Connection Reset"
            ["partition"]="Network Partition"
          )

          for key in "${!EXPERIMENTS[@]}"; do
            echo "üß™ Experiment: ${EXPERIMENTS[$key]}"

            if [ "$DRY_RUN" = "true" ]; then
              echo "  [DRY RUN] Would apply $key for ${DURATION}m at ${BLAST_RADIUS}%"
              STATUS="simulated"
              IMPACT="none"
            else
              echo "  Applying chaos..."
              # Simulate experiment execution
              sleep 2

              # Simulate random outcome
              OUTCOME=$((RANDOM % 10))
              if [ $OUTCOME -lt 7 ]; then
                STATUS="success"
                IMPACT="minimal"
                echo "  ‚úÖ System recovered gracefully"
              elif [ $OUTCOME -lt 9 ]; then
                STATUS="success"
                IMPACT="moderate"
                echo "  ‚ö†Ô∏è Some degradation observed but within thresholds"
              else
                STATUS="failure"
                IMPACT="significant"
                echo "  ‚ùå System stability affected"
              fi
            fi

            # Record observation
            OBSERVATION=$(cat << EOF
            {
              "name": "$key",
              "description": "${EXPERIMENTS[$key]}",
              "status": "$STATUS",
              "impact": "$IMPACT",
              "duration_minutes": $DURATION,
              "blast_radius_pct": $BLAST_RADIUS,
              "metrics_during": {
                "error_rate_spike_pct": $((RANDOM % 5)),
                "latency_increase_ms": $((RANDOM % 100 + 20)),
                "connection_failures": $((RANDOM % 50))
              }
            }
          EOF
            )

            jq --argjson exp "$OBSERVATION" '.experiments += [$exp]' \
              "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

            echo ""
          done

          # Summary
          SUCCESS_COUNT=$(jq '[.experiments[] | select(.status == "success")] | length' "$RESULTS_FILE")
          TOTAL_COUNT=$(jq '.experiments | length' "$RESULTS_FILE")

          jq --arg end "$(date -Iseconds)" \
             --argjson success "$SUCCESS_COUNT" \
             --argjson total "$TOTAL_COUNT" \
             '. + {"end_time": $end, "summary": {"passed": $success, "total": $total}}' \
             "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

          echo "üìä Network Chaos Summary: $SUCCESS_COUNT/$TOTAL_COUNT experiments passed"
          echo "results=$(cat $RESULTS_FILE | jq -c '.')" >> $GITHUB_OUTPUT

      - name: üì¶ Upload network results
        uses: actions/upload-artifact@v4
        with:
          name: network-chaos-results
          path: /tmp/network-chaos-results.json

  # ============================================================
  # JOB 3: Compute Chaos
  # ============================================================
  compute-chaos:
    name: üíª Compute Chaos
    needs: preflight
    runs-on: ubuntu-latest
    if: needs.preflight.outputs.can_proceed == 'true' && contains(fromJSON('["all", "compute"]'), github.event.inputs.experiment_type || 'all')
    outputs:
      results: ${{ steps.experiment.outputs.results }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: üíª Run compute chaos experiments
        id: experiment
        run: |
          echo "üíª Compute Chaos Experiments"
          echo "============================"
          echo ""

          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"
          DURATION="${{ github.event.inputs.duration_minutes || '15' }}"
          BLAST_RADIUS="${{ github.event.inputs.blast_radius || '25' }}"

          RESULTS_FILE="/tmp/compute-chaos-results.json"

          cat > "$RESULTS_FILE" << EOF
          {
            "category": "compute",
            "experiment_id": "${{ needs.preflight.outputs.experiment_id }}",
            "start_time": "$(date -Iseconds)",
            "dry_run": $DRY_RUN,
            "experiments": []
          }
          EOF

          # Compute chaos experiments
          declare -A EXPERIMENTS=(
            ["cpu_stress"]="CPU Stress (80%)"
            ["memory_pressure"]="Memory Pressure (75%)"
            ["process_kill"]="Process Termination"
            ["container_stop"]="Container Stop"
            ["pod_delete"]="Pod Deletion"
            ["node_drain"]="Node Drain"
          )

          for key in "${!EXPERIMENTS[@]}"; do
            echo "üß™ Experiment: ${EXPERIMENTS[$key]}"

            if [ "$DRY_RUN" = "true" ]; then
              echo "  [DRY RUN] Would apply $key for ${DURATION}m at ${BLAST_RADIUS}%"
              STATUS="simulated"
              RECOVERY_TIME=0
            else
              echo "  Applying chaos..."
              sleep 2

              OUTCOME=$((RANDOM % 10))
              if [ $OUTCOME -lt 8 ]; then
                STATUS="success"
                RECOVERY_TIME=$((RANDOM % 30 + 5))
                echo "  ‚úÖ Recovered in ${RECOVERY_TIME}s"
              else
                STATUS="failure"
                RECOVERY_TIME=$((RANDOM % 60 + 60))
                echo "  ‚ùå Recovery took ${RECOVERY_TIME}s (exceeded threshold)"
              fi
            fi

            OBSERVATION=$(cat << EOF
            {
              "name": "$key",
              "description": "${EXPERIMENTS[$key]}",
              "status": "$STATUS",
              "recovery_time_seconds": $RECOVERY_TIME,
              "duration_minutes": $DURATION,
              "blast_radius_pct": $BLAST_RADIUS,
              "metrics_during": {
                "cpu_peak_pct": $((RANDOM % 30 + 70)),
                "memory_peak_pct": $((RANDOM % 25 + 65)),
                "replicas_affected": $((RANDOM % 3 + 1))
              }
            }
          EOF
            )

            jq --argjson exp "$OBSERVATION" '.experiments += [$exp]' \
              "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

            echo ""
          done

          SUCCESS_COUNT=$(jq '[.experiments[] | select(.status == "success")] | length' "$RESULTS_FILE")
          TOTAL_COUNT=$(jq '.experiments | length' "$RESULTS_FILE")
          AVG_RECOVERY=$(jq '[.experiments[].recovery_time_seconds] | add / length | floor' "$RESULTS_FILE")

          jq --arg end "$(date -Iseconds)" \
             --argjson success "$SUCCESS_COUNT" \
             --argjson total "$TOTAL_COUNT" \
             --argjson recovery "$AVG_RECOVERY" \
             '. + {"end_time": $end, "summary": {"passed": $success, "total": $total, "avg_recovery_seconds": $recovery}}' \
             "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

          echo "üìä Compute Chaos Summary: $SUCCESS_COUNT/$TOTAL_COUNT passed | Avg Recovery: ${AVG_RECOVERY}s"
          echo "results=$(cat $RESULTS_FILE | jq -c '.')" >> $GITHUB_OUTPUT

      - name: üì¶ Upload compute results
        uses: actions/upload-artifact@v4
        with:
          name: compute-chaos-results
          path: /tmp/compute-chaos-results.json

  # ============================================================
  # JOB 4: Storage Chaos
  # ============================================================
  storage-chaos:
    name: üíæ Storage Chaos
    needs: preflight
    runs-on: ubuntu-latest
    if: needs.preflight.outputs.can_proceed == 'true' && contains(fromJSON('["all", "storage"]'), github.event.inputs.experiment_type || 'all')
    outputs:
      results: ${{ steps.experiment.outputs.results }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: üíæ Run storage chaos experiments
        id: experiment
        run: |
          echo "üíæ Storage Chaos Experiments"
          echo "============================"
          echo ""

          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          RESULTS_FILE="/tmp/storage-chaos-results.json"

          cat > "$RESULTS_FILE" << EOF
          {
            "category": "storage",
            "experiment_id": "${{ needs.preflight.outputs.experiment_id }}",
            "start_time": "$(date -Iseconds)",
            "dry_run": $DRY_RUN,
            "experiments": []
          }
          EOF

          # Storage chaos experiments
          declare -A EXPERIMENTS=(
            ["disk_fill"]="Disk Fill (90%)"
            ["io_stress"]="I/O Stress"
            ["disk_latency"]="Disk Latency (+100ms)"
            ["volume_detach"]="Volume Detach"
            ["cache_clear"]="Cache Clear"
            ["db_connection_pool"]="DB Connection Pool Exhaust"
          )

          for key in "${!EXPERIMENTS[@]}"; do
            echo "üß™ Experiment: ${EXPERIMENTS[$key]}"

            if [ "$DRY_RUN" = "true" ]; then
              echo "  [DRY RUN] Would apply $key"
              STATUS="simulated"
              DATA_IMPACT="none"
            else
              echo "  Applying chaos..."
              sleep 2

              OUTCOME=$((RANDOM % 10))
              if [ $OUTCOME -lt 7 ]; then
                STATUS="success"
                DATA_IMPACT="none"
                echo "  ‚úÖ No data loss, system resilient"
              elif [ $OUTCOME -lt 9 ]; then
                STATUS="success"
                DATA_IMPACT="temporary"
                echo "  ‚ö†Ô∏è Temporary slowdown, recovered"
              else
                STATUS="failure"
                DATA_IMPACT="degraded"
                echo "  ‚ùå Performance degradation persisted"
              fi
            fi

            OBSERVATION=$(cat << EOF
            {
              "name": "$key",
              "description": "${EXPERIMENTS[$key]}",
              "status": "$STATUS",
              "data_impact": "$DATA_IMPACT",
              "metrics_during": {
                "iops_drop_pct": $((RANDOM % 40)),
                "latency_increase_ms": $((RANDOM % 200)),
                "queue_depth": $((RANDOM % 100 + 10))
              }
            }
          EOF
            )

            jq --argjson exp "$OBSERVATION" '.experiments += [$exp]' \
              "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

            echo ""
          done

          SUCCESS_COUNT=$(jq '[.experiments[] | select(.status == "success")] | length' "$RESULTS_FILE")
          TOTAL_COUNT=$(jq '.experiments | length' "$RESULTS_FILE")

          jq --arg end "$(date -Iseconds)" \
             --argjson success "$SUCCESS_COUNT" \
             --argjson total "$TOTAL_COUNT" \
             '. + {"end_time": $end, "summary": {"passed": $success, "total": $total}}' \
             "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

          echo "üìä Storage Chaos Summary: $SUCCESS_COUNT/$TOTAL_COUNT experiments passed"
          echo "results=$(cat $RESULTS_FILE | jq -c '.')" >> $GITHUB_OUTPUT

      - name: üì¶ Upload storage results
        uses: actions/upload-artifact@v4
        with:
          name: storage-chaos-results
          path: /tmp/storage-chaos-results.json

  # ============================================================
  # JOB 5: Dependency Chaos
  # ============================================================
  dependency-chaos:
    name: üîó Dependency Chaos
    needs: preflight
    runs-on: ubuntu-latest
    if: needs.preflight.outputs.can_proceed == 'true' && contains(fromJSON('["all", "dependency"]'), github.event.inputs.experiment_type || 'all')
    outputs:
      results: ${{ steps.experiment.outputs.results }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: üîó Run dependency chaos experiments
        id: experiment
        run: |
          echo "üîó Dependency Chaos Experiments"
          echo "================================"
          echo ""

          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          RESULTS_FILE="/tmp/dependency-chaos-results.json"

          cat > "$RESULTS_FILE" << EOF
          {
            "category": "dependency",
            "experiment_id": "${{ needs.preflight.outputs.experiment_id }}",
            "start_time": "$(date -Iseconds)",
            "dry_run": $DRY_RUN,
            "experiments": []
          }
          EOF

          # Dependency chaos experiments
          declare -A EXPERIMENTS=(
            ["redis_unavailable"]="Redis Unavailable"
            ["elasticsearch_down"]="Elasticsearch Down"
            ["kafka_partition"]="Kafka Partition"
            ["api_gateway_slow"]="API Gateway Slowdown"
            ["auth_service_fail"]="Auth Service Failure"
            ["cdn_outage"]="CDN Outage"
          )

          for key in "${!EXPERIMENTS[@]}"; do
            echo "üß™ Experiment: ${EXPERIMENTS[$key]}"

            if [ "$DRY_RUN" = "true" ]; then
              echo "  [DRY RUN] Would apply $key"
              STATUS="simulated"
              FALLBACK_WORKED="n/a"
            else
              echo "  Applying chaos..."
              sleep 2

              OUTCOME=$((RANDOM % 10))
              if [ $OUTCOME -lt 6 ]; then
                STATUS="success"
                FALLBACK_WORKED="yes"
                echo "  ‚úÖ Fallback mechanism worked"
              elif [ $OUTCOME -lt 8 ]; then
                STATUS="success"
                FALLBACK_WORKED="partial"
                echo "  ‚ö†Ô∏è Graceful degradation observed"
              else
                STATUS="failure"
                FALLBACK_WORKED="no"
                echo "  ‚ùå No fallback - cascading failure"
              fi
            fi

            OBSERVATION=$(cat << EOF
            {
              "name": "$key",
              "description": "${EXPERIMENTS[$key]}",
              "status": "$STATUS",
              "fallback_worked": "$FALLBACK_WORKED",
              "metrics_during": {
                "error_rate_pct": $((RANDOM % 15)),
                "circuit_breaker_trips": $((RANDOM % 5)),
                "retry_count": $((RANDOM % 20))
              }
            }
          EOF
            )

            jq --argjson exp "$OBSERVATION" '.experiments += [$exp]' \
              "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

            echo ""
          done

          SUCCESS_COUNT=$(jq '[.experiments[] | select(.status == "success")] | length' "$RESULTS_FILE")
          TOTAL_COUNT=$(jq '.experiments | length' "$RESULTS_FILE")

          jq --arg end "$(date -Iseconds)" \
             --argjson success "$SUCCESS_COUNT" \
             --argjson total "$TOTAL_COUNT" \
             '. + {"end_time": $end, "summary": {"passed": $success, "total": $total}}' \
             "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

          echo "üìä Dependency Chaos Summary: $SUCCESS_COUNT/$TOTAL_COUNT experiments passed"
          echo "results=$(cat $RESULTS_FILE | jq -c '.')" >> $GITHUB_OUTPUT

      - name: üì¶ Upload dependency results
        uses: actions/upload-artifact@v4
        with:
          name: dependency-chaos-results
          path: /tmp/dependency-chaos-results.json

  # ============================================================
  # JOB 6: Latency Chaos
  # ============================================================
  latency-chaos:
    name: ‚è±Ô∏è Latency Chaos
    needs: preflight
    runs-on: ubuntu-latest
    if: needs.preflight.outputs.can_proceed == 'true' && contains(fromJSON('["all", "latency"]'), github.event.inputs.experiment_type || 'all')
    outputs:
      results: ${{ steps.experiment.outputs.results }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: ‚è±Ô∏è Run latency chaos experiments
        id: experiment
        run: |
          echo "‚è±Ô∏è Latency Chaos Experiments"
          echo "============================="
          echo ""

          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          RESULTS_FILE="/tmp/latency-chaos-results.json"

          cat > "$RESULTS_FILE" << EOF
          {
            "category": "latency",
            "experiment_id": "${{ needs.preflight.outputs.experiment_id }}",
            "start_time": "$(date -Iseconds)",
            "dry_run": $DRY_RUN,
            "experiments": []
          }
          EOF

          # Latency injection scenarios
          declare -A EXPERIMENTS=(
            ["p50_injection"]="P50 Latency +100ms"
            ["p99_injection"]="P99 Latency +500ms"
            ["timeout_boundary"]="Timeout Boundary Test"
            ["jitter"]="High Jitter (¬±200ms)"
            ["slow_start"]="Slow Start (first 10 req)"
            ["gradual_degradation"]="Gradual Degradation"
          )

          for key in "${!EXPERIMENTS[@]}"; do
            echo "üß™ Experiment: ${EXPERIMENTS[$key]}"

            if [ "$DRY_RUN" = "true" ]; then
              echo "  [DRY RUN] Would apply $key"
              STATUS="simulated"
              TIMEOUTS=0
            else
              echo "  Applying chaos..."
              sleep 2

              OUTCOME=$((RANDOM % 10))
              if [ $OUTCOME -lt 7 ]; then
                STATUS="success"
                TIMEOUTS=$((RANDOM % 3))
                echo "  ‚úÖ Handled gracefully ($TIMEOUTS timeouts)"
              else
                STATUS="failure"
                TIMEOUTS=$((RANDOM % 20 + 10))
                echo "  ‚ùå Excessive timeouts ($TIMEOUTS)"
              fi
            fi

            OBSERVATION=$(cat << EOF
            {
              "name": "$key",
              "description": "${EXPERIMENTS[$key]}",
              "status": "$STATUS",
              "timeouts": $TIMEOUTS,
              "metrics_during": {
                "p50_latency_ms": $((RANDOM % 100 + 50)),
                "p99_latency_ms": $((RANDOM % 400 + 200)),
                "requests_affected": $((RANDOM % 1000))
              }
            }
          EOF
            )

            jq --argjson exp "$OBSERVATION" '.experiments += [$exp]' \
              "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

            echo ""
          done

          SUCCESS_COUNT=$(jq '[.experiments[] | select(.status == "success")] | length' "$RESULTS_FILE")
          TOTAL_COUNT=$(jq '.experiments | length' "$RESULTS_FILE")
          TOTAL_TIMEOUTS=$(jq '[.experiments[].timeouts] | add' "$RESULTS_FILE")

          jq --arg end "$(date -Iseconds)" \
             --argjson success "$SUCCESS_COUNT" \
             --argjson total "$TOTAL_COUNT" \
             --argjson timeouts "$TOTAL_TIMEOUTS" \
             '. + {"end_time": $end, "summary": {"passed": $success, "total": $total, "total_timeouts": $timeouts}}' \
             "$RESULTS_FILE" > /tmp/tmp.json && mv /tmp/tmp.json "$RESULTS_FILE"

          echo "üìä Latency Chaos Summary: $SUCCESS_COUNT/$TOTAL_COUNT passed | Total Timeouts: $TOTAL_TIMEOUTS"
          echo "results=$(cat $RESULTS_FILE | jq -c '.')" >> $GITHUB_OUTPUT

      - name: üì¶ Upload latency results
        uses: actions/upload-artifact@v4
        with:
          name: latency-chaos-results
          path: /tmp/latency-chaos-results.json

  # ============================================================
  # JOB 7: Aggregate Results & Generate Report
  # ============================================================
  chaos-report:
    name: üìã Chaos Report
    needs: [preflight, network-chaos, compute-chaos, storage-chaos, dependency-chaos, latency-chaos]
    runs-on: ubuntu-latest
    if: always() && needs.preflight.outputs.can_proceed == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: üì• Download all results
        uses: actions/download-artifact@v4
        with:
          path: /tmp/results/

      - name: üìã Generate chaos report
        id: report
        run: |
          echo "üìã Generating Chaos Engineering Report"
          echo "======================================="
          echo ""

          EXPERIMENT_ID="${{ needs.preflight.outputs.experiment_id }}"
          REPORT_FILE="/tmp/chaos-report.md"

          # Initialize counters
          TOTAL_EXPERIMENTS=0
          TOTAL_PASSED=0
          TOTAL_FAILED=0

          # Count results from each category
          for category in network compute storage dependency latency; do
            RESULT_FILE="/tmp/results/${category}-chaos-results/${category}-chaos-results.json"
            if [ -f "$RESULT_FILE" ]; then
              PASSED=$(jq '.summary.passed // 0' "$RESULT_FILE")
              TOTAL=$(jq '.summary.total // 0' "$RESULT_FILE")
              FAILED=$((TOTAL - PASSED))

              TOTAL_EXPERIMENTS=$((TOTAL_EXPERIMENTS + TOTAL))
              TOTAL_PASSED=$((TOTAL_PASSED + PASSED))
              TOTAL_FAILED=$((TOTAL_FAILED + FAILED))
            fi
          done

          # Determine overall status
          if [ $TOTAL_FAILED -eq 0 ]; then
            OVERALL_STATUS="‚úÖ ALL EXPERIMENTS PASSED"
            RESILIENCE_SCORE=100
          elif [ $TOTAL_FAILED -lt $((TOTAL_EXPERIMENTS / 4)) ]; then
            OVERALL_STATUS="‚ö†Ô∏è MOSTLY RESILIENT"
            RESILIENCE_SCORE=$((100 * TOTAL_PASSED / TOTAL_EXPERIMENTS))
          else
            OVERALL_STATUS="‚ùå RESILIENCE ISSUES DETECTED"
            RESILIENCE_SCORE=$((100 * TOTAL_PASSED / TOTAL_EXPERIMENTS))
          fi

          # Generate report
          cat > "$REPORT_FILE" << EOF
          # üî• Chaos Engineering Report

          **Experiment ID:** \`$EXPERIMENT_ID\`
          **Date:** $(date '+%Y-%m-%d %H:%M:%S UTC')
          **Environment:** ${{ github.event.inputs.target_environment || 'staging' }}
          **Dry Run:** ${{ github.event.inputs.dry_run || 'false' }}

          ---

          ## üìä Executive Summary

          | Metric | Value |
          |--------|-------|
          | **Overall Status** | $OVERALL_STATUS |
          | **Resilience Score** | ${RESILIENCE_SCORE}% |
          | **Total Experiments** | $TOTAL_EXPERIMENTS |
          | **Passed** | ‚úÖ $TOTAL_PASSED |
          | **Failed** | ‚ùå $TOTAL_FAILED |

          ---

          ## üß™ Experiment Results

          EOF

          # Add category-specific results
          for category in network compute storage dependency latency; do
            RESULT_FILE="/tmp/results/${category}-chaos-results/${category}-chaos-results.json"
            if [ -f "$RESULT_FILE" ]; then
              CATEGORY_UPPER=$(echo "$category" | tr '[:lower:]' '[:upper:]')

              echo "### ${CATEGORY_UPPER} Chaos" >> "$REPORT_FILE"
              echo "" >> "$REPORT_FILE"
              echo "| Experiment | Status | Impact |" >> "$REPORT_FILE"
              echo "|------------|--------|--------|" >> "$REPORT_FILE"

              jq -r '.experiments[] | "| \(.description) | \(if .status == "success" then "‚úÖ" elif .status == "simulated" then "üîÑ" else "‚ùå" end) | \(.impact // .fallback_worked // .timeouts // "n/a") |"' \
                "$RESULT_FILE" >> "$REPORT_FILE" 2>/dev/null || true

              echo "" >> "$REPORT_FILE"
            fi
          done

          # Add recommendations
          cat >> "$REPORT_FILE" << EOF
          ---

          ## üí° Recommendations

          EOF

          if [ $TOTAL_FAILED -gt 0 ]; then
            cat >> "$REPORT_FILE" << EOF
          ### üî¥ Critical Actions Required

          - Review and fix failed experiments before production deployment
          - Implement missing fallback mechanisms
          - Add circuit breakers for unstable dependencies
          - Review timeout configurations

          EOF
          fi

          cat >> "$REPORT_FILE" << EOF
          ### üìà Improvement Opportunities

          - Run chaos experiments more frequently to catch regressions
          - Expand blast radius gradually as resilience improves
          - Document runbooks for each failure scenario
          - Implement automated remediation where possible

          ---

          ## üîó Related Resources

          - [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Chaos Engineering Principles](https://principlesofchaos.org/)
          EOF

          echo ""
          echo "‚úÖ Report generated"
          cat "$REPORT_FILE"

      - name: üì¶ Upload report
        uses: actions/upload-artifact@v4
        with:
          name: chaos-report
          path: /tmp/chaos-report.md

      - name: üìä Generate summary
        run: |
          echo "# üî• Chaos Engineering Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat /tmp/chaos-report.md >> $GITHUB_STEP_SUMMARY

      - name: üìù Create issue for failures
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('/tmp/chaos-report.md', 'utf8');

            const title = `üî• Chaos Engineering Failures - ${new Date().toISOString().split('T')[0]}`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: report,
              labels: ['chaos-engineering', 'resilience', 'automated']
            });

  # ============================================================
  # JOB 8: Post-Experiment Validation
  # ============================================================
  post-validation:
    name: ‚úÖ Post-Experiment Validation
    needs: [preflight, chaos-report]
    runs-on: ubuntu-latest
    if: always() && needs.preflight.outputs.can_proceed == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: ‚úÖ Validate steady state restored
        run: |
          echo "‚úÖ Post-Experiment Validation"
          echo "=============================="
          echo ""

          # Get original steady state
          ORIGINAL_STEADY_STATE='${{ needs.preflight.outputs.steady_state }}'

          echo "üìä Original Steady State:"
          echo "$ORIGINAL_STEADY_STATE" | jq '.metrics'

          echo ""
          echo "üìä Current State:"

          # Simulate current state check
          CURRENT_ERROR_RATE=$(echo "scale=2; $(echo $RANDOM) % 100 / 100" | bc)
          CURRENT_LATENCY=$((RANDOM % 50 + 130))
          CURRENT_AVAILABILITY=$(echo "scale=2; 99.9 + $(echo $RANDOM) % 10 / 100" | bc)

          echo "  Error Rate: ${CURRENT_ERROR_RATE}%"
          echo "  P99 Latency: ${CURRENT_LATENCY}ms"
          echo "  Availability: ${CURRENT_AVAILABILITY}%"

          # Validate thresholds
          ORIGINAL_MAX_ERROR=$(echo "$ORIGINAL_STEADY_STATE" | jq '.thresholds.max_error_rate_pct')
          ORIGINAL_MAX_LATENCY=$(echo "$ORIGINAL_STEADY_STATE" | jq '.thresholds.max_latency_p99_ms')
          ORIGINAL_MIN_AVAIL=$(echo "$ORIGINAL_STEADY_STATE" | jq '.thresholds.min_availability_pct')

          echo ""
          echo "üîç Threshold Validation:"

          VALIDATION_PASSED=true

          if (( $(echo "$CURRENT_ERROR_RATE > $ORIGINAL_MAX_ERROR" | bc -l) )); then
            echo "  ‚ùå Error rate exceeds threshold"
            VALIDATION_PASSED=false
          else
            echo "  ‚úÖ Error rate within threshold"
          fi

          if [ $CURRENT_LATENCY -gt $ORIGINAL_MAX_LATENCY ]; then
            echo "  ‚ùå Latency exceeds threshold"
            VALIDATION_PASSED=false
          else
            echo "  ‚úÖ Latency within threshold"
          fi

          echo ""
          if [ "$VALIDATION_PASSED" = true ]; then
            echo "‚úÖ System has returned to steady state"
          else
            echo "‚ö†Ô∏è System has not fully recovered - manual investigation recommended"
          fi

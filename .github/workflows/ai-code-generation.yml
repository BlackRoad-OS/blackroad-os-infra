name: AI-Powered Code Generation

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      feature_description:
        description: 'Feature to generate'
        required: true
        type: string
      target_language:
        description: 'Target language'
        required: true
        type: choice
        options:
          - javascript
          - typescript
          - python
          - rust
          - go

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  detect-code-request:
    name: Detect Code Generation Request
    runs-on: ubuntu-latest
    outputs:
      should_generate: ${{ steps.detect.outputs.generate }}
      feature_spec: ${{ steps.detect.outputs.spec }}
      language: ${{ steps.detect.outputs.language }}
    steps:
      - name: Detect generation trigger
        id: detect
        uses: actions/github-script@v7
        with:
          script: |
            let shouldGenerate = false;
            let featureSpec = '';
            let language = 'typescript';

            // Workflow dispatch
            if (context.eventName === 'workflow_dispatch') {
              shouldGenerate = true;
              featureSpec = '${{ github.event.inputs.feature_description }}';
              language = '${{ github.event.inputs.target_language }}';
            }
            // Issue with 'generate-code' label
            else if (context.payload.issue) {
              const issue = context.payload.issue;
              const hasLabel = issue.labels.some(l => l.name === 'generate-code');

              if (hasLabel) {
                shouldGenerate = true;
                featureSpec = issue.title + '\n\n' + issue.body;

                // Detect language from issue
                const text = featureSpec.toLowerCase();
                if (text.includes('python')) language = 'python';
                else if (text.includes('rust')) language = 'rust';
                else if (text.includes('go')) language = 'go';
                else if (text.includes('javascript')) language = 'javascript';
              }
            }

            core.setOutput('generate', shouldGenerate ? 'true' : 'false');
            core.setOutput('spec', featureSpec);
            core.setOutput('language', language);

            console.log(`Should generate: ${shouldGenerate}`);
            console.log(`Language: ${language}`);

  analyze-requirements:
    name: Analyze Code Requirements
    runs-on: ubuntu-latest
    needs: detect-code-request
    if: needs.detect-code-request.outputs.should_generate == 'true'
    outputs:
      components: ${{ steps.analyze.outputs.components }}
      complexity: ${{ steps.analyze.outputs.complexity }}
      patterns: ${{ steps.analyze.outputs.patterns }}
    steps:
      - uses: actions/checkout@v4

      - name: Analyze requirements
        id: analyze
        run: |
          spec='${{ needs.detect-code-request.outputs.feature_spec }}'

          echo "Analyzing feature specification..."
          echo "$spec"

          # Detect components needed
          components=""
          if echo "$spec" | grep -qi "api\|endpoint\|route"; then
            components="${components}api,"
          fi
          if echo "$spec" | grep -qi "database\|model\|schema"; then
            components="${components}database,"
          fi
          if echo "$spec" | grep -qi "auth\|login\|user"; then
            components="${components}auth,"
          fi
          if echo "$spec" | grep -qi "test\|spec"; then
            components="${components}tests,"
          fi
          if echo "$spec" | grep -qi "ui\|component\|frontend"; then
            components="${components}ui,"
          fi

          # Estimate complexity
          word_count=$(echo "$spec" | wc -w)
          if [ $word_count -lt 50 ]; then
            complexity="low"
          elif [ $word_count -lt 150 ]; then
            complexity="medium"
          else
            complexity="high"
          fi

          # Detect patterns
          patterns=""
          if echo "$spec" | grep -qi "crud"; then
            patterns="${patterns}crud,"
          fi
          if echo "$spec" | grep -qi "rest\|restful"; then
            patterns="${patterns}rest,"
          fi
          if echo "$spec" | grep -qi "microservice"; then
            patterns="${patterns}microservice,"
          fi
          if echo "$spec" | grep -qi "event\|queue\|async"; then
            patterns="${patterns}event-driven,"
          fi

          echo "components=$components" >> $GITHUB_OUTPUT
          echo "complexity=$complexity" >> $GITHUB_OUTPUT
          echo "patterns=$patterns" >> $GITHUB_OUTPUT

          echo "Components: $components"
          echo "Complexity: $complexity"
          echo "Patterns: $patterns"

  generate-code-structure:
    name: Generate Code Structure
    runs-on: ubuntu-latest
    needs: [detect-code-request, analyze-requirements]
    outputs:
      files_created: ${{ steps.generate.outputs.files }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate code
        id: generate
        run: |
          language='${{ needs.detect-code-request.outputs.language }}'
          components='${{ needs.analyze-requirements.outputs.components }}'
          spec='${{ needs.detect-code-request.outputs.feature_spec }}'

          echo "Generating code for language: $language"
          echo "Components: $components"

          mkdir -p generated/src
          files=""

          # Generate based on language and components
          case "$language" in
            typescript|javascript)
              ext="${language/typescript/ts}"
              ext="${ext/javascript/js}"

              # Generate API if needed
              if [[ "$components" == *"api"* ]]; then
                cat > "generated/src/api.$ext" << 'EOF'
/**
 * Auto-generated API module
 * Based on specification provided
 */

export class API {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  /**
   * Fetch data from endpoint
   */
  async get(endpoint: string): Promise<any> {
    const response = await fetch(`${this.baseUrl}${endpoint}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  }

  /**
   * Post data to endpoint
   */
  async post(endpoint: string, data: any): Promise<any> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  }
}
EOF
                files="${files}src/api.$ext,"
              fi

              # Generate model if needed
              if [[ "$components" == *"database"* ]]; then
                cat > "generated/src/model.$ext" << 'EOF'
/**
 * Auto-generated Data Model
 */

export interface Model {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export class DataStore<T extends Model> {
  private items: Map<string, T> = new Map();

  create(item: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): T {
    const newItem = {
      ...item,
      id: crypto.randomUUID(),
      createdAt: new Date(),
      updatedAt: new Date()
    } as T;

    this.items.set(newItem.id, newItem);
    return newItem;
  }

  findById(id: string): T | undefined {
    return this.items.get(id);
  }

  findAll(): T[] {
    return Array.from(this.items.values());
  }

  update(id: string, updates: Partial<T>): T | undefined {
    const item = this.items.get(id);
    if (!item) return undefined;

    const updated = {
      ...item,
      ...updates,
      updatedAt: new Date()
    };

    this.items.set(id, updated);
    return updated;
  }

  delete(id: string): boolean {
    return this.items.delete(id);
  }
}
EOF
                files="${files}src/model.$ext,"
              fi
              ;;

            python)
              if [[ "$components" == *"api"* ]]; then
                cat > "generated/src/api.py" << 'EOF'
"""
Auto-generated API module
Based on specification provided
"""

import requests
from typing import Any, Dict


class API:
    """API client for making HTTP requests"""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session = requests.Session()

    def get(self, endpoint: str) -> Any:
        """Fetch data from endpoint"""
        response = self.session.get(f"{self.base_url}{endpoint}")
        response.raise_for_status()
        return response.json()

    def post(self, endpoint: str, data: Dict[str, Any]) -> Any:
        """Post data to endpoint"""
        response = self.session.post(
            f"{self.base_url}{endpoint}",
            json=data
        )
        response.raise_for_status()
        return response.json()

    def put(self, endpoint: str, data: Dict[str, Any]) -> Any:
        """Update data at endpoint"""
        response = self.session.put(
            f"{self.base_url}{endpoint}",
            json=data
        )
        response.raise_for_status()
        return response.json()

    def delete(self, endpoint: str) -> bool:
        """Delete resource at endpoint"""
        response = self.session.delete(f"{self.base_url}{endpoint}")
        response.raise_for_status()
        return response.status_code == 204
EOF
                files="${files}src/api.py,"
              fi

              if [[ "$components" == *"database"* ]]; then
                cat > "generated/src/model.py" << 'EOF'
"""
Auto-generated Data Model
"""

from datetime import datetime
from typing import Dict, List, Optional, TypeVar, Generic
from dataclasses import dataclass, field
import uuid


@dataclass
class Model:
    """Base model with common fields"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)


T = TypeVar('T', bound=Model)


class DataStore(Generic[T]):
    """Generic data store for managing models"""

    def __init__(self):
        self._items: Dict[str, T] = {}

    def create(self, item: T) -> T:
        """Create a new item"""
        item.created_at = datetime.now()
        item.updated_at = datetime.now()
        self._items[item.id] = item
        return item

    def find_by_id(self, id: str) -> Optional[T]:
        """Find item by ID"""
        return self._items.get(id)

    def find_all(self) -> List[T]:
        """Get all items"""
        return list(self._items.values())

    def update(self, id: str, updates: Dict) -> Optional[T]:
        """Update an item"""
        item = self._items.get(id)
        if not item:
            return None

        for key, value in updates.items():
            setattr(item, key, value)

        item.updated_at = datetime.now()
        return item

    def delete(self, id: str) -> bool:
        """Delete an item"""
        if id in self._items:
            del self._items[id]
            return True
        return False
EOF
                files="${files}src/model.py,"
              fi
              ;;
          esac

          # Generate README
          cat > "generated/README.md" << EOF
# Auto-Generated Code

**Language:** $language
**Components:** $components
**Complexity:** ${{ needs.analyze-requirements.outputs.complexity }}

## Specification

$spec

## Generated Files

$(echo "$files" | tr ',' '\n' | sed 's/^/- /')

## Usage

Review the generated code and customize as needed for your specific use case.

---
ðŸ¤– Auto-generated by AI Code Generation System
EOF
          files="${files}README.md"

          echo "files=$files" >> $GITHUB_OUTPUT
          echo "Generated files: $files"

      - name: Upload generated code
        uses: actions/upload-artifact@v4
        with:
          name: generated-code
          path: generated/

  generate-tests:
    name: Generate Tests
    runs-on: ubuntu-latest
    needs: [detect-code-request, analyze-requirements, generate-code-structure]
    steps:
      - uses: actions/checkout@v4

      - name: Download generated code
        uses: actions/download-artifact@v4
        with:
          name: generated-code
          path: generated/

      - name: Generate test files
        run: |
          language='${{ needs.detect-code-request.outputs.language }}'

          echo "Generating tests for $language..."

          case "$language" in
            typescript|javascript)
              ext="${language/typescript/ts}"
              ext="${ext/javascript/js}"

              cat > "generated/src/api.test.$ext" << 'EOF'
/**
 * Auto-generated tests for API module
 */

import { API } from './api';

describe('API', () => {
  let api: API;

  beforeEach(() => {
    api = new API('https://api.example.com');
  });

  test('should create API instance', () => {
    expect(api).toBeDefined();
  });

  test('should make GET request', async () => {
    // Mock implementation would go here
    expect(api.get).toBeDefined();
  });

  test('should make POST request', async () => {
    // Mock implementation would go here
    expect(api.post).toBeDefined();
  });
});
EOF
              ;;

            python)
              cat > "generated/src/test_api.py" << 'EOF'
"""
Auto-generated tests for API module
"""

import pytest
from src.api import API


@pytest.fixture
def api():
    return API('https://api.example.com')


def test_api_instance(api):
    """Test API instance creation"""
    assert api is not None
    assert api.base_url == 'https://api.example.com'


def test_get_method_exists(api):
    """Test GET method exists"""
    assert hasattr(api, 'get')


def test_post_method_exists(api):
    """Test POST method exists"""
    assert hasattr(api, 'post')
EOF
              ;;
          esac

          echo "âœ“ Tests generated"

      - name: Upload code with tests
        uses: actions/upload-artifact@v4
        with:
          name: generated-code-with-tests
          path: generated/

  create-pr-with-code:
    name: Create PR with Generated Code
    runs-on: ubuntu-latest
    needs: [detect-code-request, analyze-requirements, generate-code-structure, generate-tests]
    steps:
      - uses: actions/checkout@v4

      - name: Download generated code
        uses: actions/download-artifact@v4
        with:
          name: generated-code-with-tests
          path: generated-code/

      - name: Create feature branch and PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const branchName = `ai-generated/feature-${Date.now()}`;
            const spec = `${{ needs.detect-code-request.outputs.feature_spec }}`;
            const language = '${{ needs.detect-code-request.outputs.language }}';
            const complexity = '${{ needs.analyze-requirements.outputs.complexity }}';
            const files = '${{ needs.generate-code-structure.outputs.files }}';

            // Create branch
            const { data: ref } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main'
            });

            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/heads/${branchName}`,
              sha: ref.object.sha
            });

            // Note: In a real implementation, we would commit the generated files here
            // For now, we'll create a PR with documentation

            const prBody = `## ðŸ¤– AI-Generated Code

            **Language:** ${language}
            **Complexity:** ${complexity}

            ### Original Specification

            ${spec}

            ### Generated Components

            ${files.split(',').filter(f => f).map(f => `- ${f}`).join('\n')}

            ### Next Steps

            1. Download the generated code from the workflow artifacts
            2. Review and test the code
            3. Customize for your specific needs
            4. Add additional features as required

            ### Files Available in Artifacts

            - Source code files
            - Test files
            - README with usage instructions

            ---
            ðŸ¤– Auto-generated by AI Code Generation System
            `;

            // Create PR
            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ¤– AI Generated: ${spec.split('\n')[0].substring(0, 60)}...`,
              head: branchName,
              base: 'main',
              body: prBody
            }).catch(err => {
              console.log('Could not create PR:', err.message);
              return null;
            });

            if (pr) {
              console.log(`âœ“ Created PR: ${pr.data.html_url}`);

              // Add labels
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.data.number,
                labels: ['ai-generated', 'automated', language]
              }).catch(() => {});
            }

  code-generation-summary:
    name: Code Generation Summary
    runs-on: ubuntu-latest
    needs: [detect-code-request, analyze-requirements, generate-code-structure, generate-tests]
    if: always()
    steps:
      - name: Generate summary
        run: |
          echo "# ðŸ¤– AI Code Generation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Request Details" >> $GITHUB_STEP_SUMMARY
          echo "- Language: **${{ needs.detect-code-request.outputs.language }}**" >> $GITHUB_STEP_SUMMARY
          echo "- Complexity: **${{ needs.analyze-requirements.outputs.complexity }}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Analysis" >> $GITHUB_STEP_SUMMARY
          echo "- Components: ${{ needs.analyze-requirements.outputs.components }}" >> $GITHUB_STEP_SUMMARY
          echo "- Patterns: ${{ needs.analyze-requirements.outputs.patterns }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Generated Files" >> $GITHUB_STEP_SUMMARY
          echo "${{ needs.generate-code-structure.outputs.files }}" | tr ',' '\n' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review generated code in artifacts" >> $GITHUB_STEP_SUMMARY
          echo "2. Check the created PR" >> $GITHUB_STEP_SUMMARY
          echo "3. Customize and enhance as needed" >> $GITHUB_STEP_SUMMARY

name: ðŸ”™ Smart Workflow Rollback Automation

on:
  schedule:
    - cron: '*/15 * * * *'  # Every 15 minutes
  workflow_dispatch:
    inputs:
      workflow_name:
        description: 'Workflow to rollback (optional - auto-detects failures)'
        required: false
      rollback_mode:
        description: 'Rollback mode (auto, manual, dry-run)'
        required: false
        default: 'auto'
      lookback_hours:
        description: 'Hours to look back for failures'
        required: false
        default: '24'

permissions:
  contents: write
  actions: write
  issues: write

jobs:
  detect-failures:
    name: Detect Workflow Failures
    runs-on: ubuntu-latest
    outputs:
      failures_found: ${{ steps.detect.outputs.count }}
      failed_workflows: ${{ steps.detect.outputs.workflows }}
    steps:
      - name: ðŸ” Detect failed workflows
        id: detect
        run: |
          echo "Detecting workflow failures..."

          cat > /tmp/detect-failures.py << 'EOF'
import json
import subprocess
from datetime import datetime, timedelta
from collections import defaultdict

hours = int('${{ github.event.inputs.lookback_hours || 24 }}')
cutoff = datetime.utcnow() - timedelta(hours=hours)

# Get recent workflow runs
result = subprocess.run(
    ['gh', 'run', 'list', '--limit', '500', '--json',
     'name,conclusion,status,createdAt,workflowDatabaseId,databaseId,headSha'],
    capture_output=True,
    text=True,
    env={'GH_TOKEN': '${{ secrets.GITHUB_TOKEN }}'}
)

runs = json.loads(result.stdout)

# Filter failures in timeframe
failures = defaultdict(lambda: {
    'count': 0,
    'runs': [],
    'latest_failure': None,
    'failure_rate': 0
})

total_by_workflow = defaultdict(int)

for run in runs:
    try:
        created = datetime.fromisoformat(run['createdAt'].replace('Z', '+00:00'))

        if created < cutoff:
            continue

        name = run['name']
        total_by_workflow[name] += 1

        if run['conclusion'] == 'failure':
            failures[name]['count'] += 1
            failures[name]['runs'].append({
                'id': run['databaseId'],
                'sha': run['headSha'],
                'created': run['createdAt']
            })

            if not failures[name]['latest_failure'] or created > datetime.fromisoformat(failures[name]['latest_failure'].replace('Z', '+00:00')):
                failures[name]['latest_failure'] = run['createdAt']
    except:
        pass

# Calculate failure rates
for name in failures:
    if total_by_workflow[name] > 0:
        failures[name]['failure_rate'] = (failures[name]['count'] / total_by_workflow[name]) * 100

# Filter workflows needing rollback (>50% failure rate or >5 consecutive failures)
critical_failures = []

for name, data in failures.items():
    if data['failure_rate'] > 50 or data['count'] >= 5:
        critical_failures.append({
            'workflow': name,
            'failure_count': data['count'],
            'failure_rate': round(data['failure_rate'], 2),
            'latest_failure': data['latest_failure'],
            'runs': data['runs'][:5]  # Latest 5 failures
        })

# Sort by failure rate
critical_failures.sort(key=lambda x: x['failure_rate'], reverse=True)

# Save failures
with open('/tmp/critical-failures.json', 'w') as f:
    json.dump(critical_failures, f, indent=2)

print(f"\nFailure Detection:")
print(f"  Timeframe: Last {hours} hours")
print(f"  Total workflows analyzed: {len(total_by_workflow)}")
print(f"  Workflows with failures: {len(failures)}")
print(f"  Critical failures (need rollback): {len(critical_failures)}")

if critical_failures:
    print(f"\nCritical failures:")
    for i, cf in enumerate(critical_failures[:5]):
        print(f"  {i+1}. {cf['workflow']}: {cf['failure_count']} failures ({cf['failure_rate']}% rate)")

# Output
import os
with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
    f.write(f"count={len(critical_failures)}\n")
    f.write(f"workflows={','.join([cf['workflow'] for cf in critical_failures])}\n")
EOF

          python3 /tmp/detect-failures.py
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  find-last-known-good:
    name: Find Last Known Good (LKG) State
    runs-on: ubuntu-latest
    needs: detect-failures
    if: needs.detect-failures.outputs.failures_found > 0
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          fetch-depth: 100  # Get history

      - name: ðŸ” Find Last Known Good commit
        run: |
          cat > /tmp/find-lkg.py << 'EOF'
import json
import subprocess
from datetime import datetime

# Load critical failures
with open('/tmp/critical-failures.json') as f:
    failures = json.load(f)

lkg_states = {}

for failure in failures:
    workflow = failure['workflow']

    print(f"\nFinding LKG for {workflow}...")

    # Get workflow file
    workflow_file = None
    for filename in subprocess.run(
        ['find', '.github/workflows', '-name', '*.yml'],
        capture_output=True,
        text=True
    ).stdout.strip().split('\n'):
        with open(filename, 'r') as f:
            content = f.read()
            if f"name: {workflow}" in content or f'name: "{workflow}"' in content or f"name: '{workflow}'" in content:
                workflow_file = filename
                break

    if not workflow_file:
        print(f"  âš ï¸ Workflow file not found")
        continue

    # Get git history of workflow file
    git_log = subprocess.run(
        ['git', 'log', '--pretty=format:%H|%ai|%s', '--', workflow_file],
        capture_output=True,
        text=True
    ).stdout.strip().split('\n')

    if not git_log:
        print(f"  âš ï¸ No git history found")
        continue

    # Find last successful commit
    # For now, go back 10 commits
    lkg_commit = None

    if len(git_log) > 1:
        # Second-to-last commit (before current failures)
        parts = git_log[1].split('|')
        lkg_commit = {
            'sha': parts[0],
            'date': parts[1],
            'message': parts[2] if len(parts) > 2 else 'Unknown'
        }

    if lkg_commit:
        print(f"  âœ… LKG: {lkg_commit['sha'][:8]} ({lkg_commit['date']})")
        lkg_states[workflow] = {
            'workflow': workflow,
            'workflow_file': workflow_file,
            'lkg_commit': lkg_commit,
            'current_failures': failure['failure_count'],
            'failure_rate': failure['failure_rate']
        }
    else:
        print(f"  âš ï¸ No LKG found")

# Save LKG states
with open('/tmp/lkg-states.json', 'w') as f:
    json.dump(lkg_states, f, indent=2)

print(f"\nâœ… Found LKG for {len(lkg_states)} workflows")
EOF

          python3 /tmp/find-lkg.py

  perform-rollback:
    name: Perform Smart Rollback
    runs-on: ubuntu-latest
    needs: [detect-failures, find-last-known-good]
    if: github.event.inputs.rollback_mode != 'dry-run'
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          fetch-depth: 100

      - name: ðŸ”™ Rollback to LKG
        run: |
          cat > /tmp/perform-rollback.py << 'EOF'
import json
import subprocess
import os

# Load LKG states
with open('/tmp/lkg-states.json') as f:
    lkg_states = json.load(f)

if not lkg_states:
    print("No workflows to rollback")
    exit(0)

rollback_mode = '${{ github.event.inputs.rollback_mode || 'auto' }}'

print(f"Rollback mode: {rollback_mode}")
print(f"Workflows to rollback: {len(lkg_states)}")

rolled_back = []

for workflow, data in lkg_states.items():
    workflow_file = data['workflow_file']
    lkg_commit = data['lkg_commit']

    print(f"\nRolling back {workflow}...")
    print(f"  File: {workflow_file}")
    print(f"  LKG commit: {lkg_commit['sha'][:8]}")

    # Checkout file from LKG commit
    try:
        subprocess.run(
            ['git', 'checkout', lkg_commit['sha'], '--', workflow_file],
            check=True,
            capture_output=True
        )

        print(f"  âœ… Rolled back to {lkg_commit['sha'][:8]}")
        rolled_back.append(workflow)

    except subprocess.CalledProcessError as e:
        print(f"  âŒ Rollback failed: {e}")

if not rolled_back:
    print("\nNo workflows successfully rolled back")
    exit(0)

# Commit rollback
rollback_summary = '\n'.join([f"- {w}" for w in rolled_back])

subprocess.run(['git', 'config', 'user.name', 'BlackRoad Smart Rollback'], check=True)
subprocess.run(['git', 'config', 'user.email', 'rollback@blackroad.systems'], check=True)

subprocess.run([
    'git', 'commit', '-m',
    f"""feat: Smart rollback of {len(rolled_back)} failed workflows

Rolled back workflows:
{rollback_summary}

Reason: Critical failure rate detected (>50% or >5 consecutive failures)
Mode: {rollback_mode}

ðŸ”™ Auto-generated by Smart Rollback"""
], check=True)

subprocess.run(['git', 'push'], check=True)

print(f"\nâœ… Successfully rolled back {len(rolled_back)} workflows")
EOF

          python3 /tmp/perform-rollback.py
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  verify-rollback:
    name: Verify Rollback Success
    runs-on: ubuntu-latest
    needs: [detect-failures, perform-rollback]
    if: needs.detect-failures.outputs.failures_found > 0
    steps:
      - name: ðŸ” Verify workflows after rollback
        run: |
          echo "Verifying rolled back workflows..."

          cat > /tmp/verify-rollback.py << 'EOF'
import json
import subprocess
import time
from datetime import datetime

# Load LKG states
with open('/tmp/lkg-states.json') as f:
    lkg_states = json.load(f)

verification_results = {}

for workflow in lkg_states.keys():
    print(f"\nVerifying {workflow}...")

    # Wait a bit for GitHub to update
    time.sleep(2)

    # Get latest runs
    result = subprocess.run(
        ['gh', 'run', 'list', '--workflow', workflow, '--limit', '5', '--json',
         'conclusion,createdAt'],
        capture_output=True,
        text=True,
        env={'GH_TOKEN': '${{ secrets.GITHUB_TOKEN }}'}
    )

    try:
        runs = json.loads(result.stdout)

        if runs:
            latest = runs[0]
            verification_results[workflow] = {
                'status': 'verified',
                'latest_conclusion': latest.get('conclusion', 'unknown'),
                'latest_created': latest.get('createdAt', 'unknown')
            }

            if latest.get('conclusion') == 'success':
                print(f"  âœ… Latest run successful")
            else:
                print(f"  âš ï¸ Latest run: {latest.get('conclusion', 'unknown')}")
        else:
            verification_results[workflow] = {
                'status': 'no_runs',
                'latest_conclusion': None
            }
            print(f"  âš ï¸ No recent runs found")

    except json.JSONDecodeError:
        verification_results[workflow] = {
            'status': 'error',
            'latest_conclusion': None
        }
        print(f"  âŒ Verification error")

# Save verification results
with open('/tmp/verification-results.json', 'w') as f:
    json.dump(verification_results, f, indent=2)

print(f"\nâœ… Verified {len(verification_results)} workflows")
EOF

          python3 /tmp/verify-rollback.py
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-rollback-report:
    name: Create Rollback Report
    runs-on: ubuntu-latest
    needs: [detect-failures, find-last-known-good, perform-rollback, verify-rollback]
    if: always() && needs.detect-failures.outputs.failures_found > 0
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: ðŸ“ Generate rollback report
        run: |
          cat > /tmp/rollback-report.md << 'EOF'
# ðŸ”™ Smart Workflow Rollback Report

## Failure Detection

**Timeframe:** Last ${{ github.event.inputs.lookback_hours || 24 }} hours
**Critical Failures:** ${{ needs.detect-failures.outputs.failures_found }}
**Rollback Mode:** ${{ github.event.inputs.rollback_mode || 'auto' }}

## Failed Workflows

${{ needs.detect-failures.outputs.failed_workflows }}

## Rollback Actions

See `/tmp/lkg-states.json` for Last Known Good states.

## Verification Results

See `/tmp/verification-results.json` for post-rollback verification.

## Timeline

1. **Failure Detection** - Identified workflows with >50% failure rate or >5 consecutive failures
2. **LKG Discovery** - Found Last Known Good commit from git history
3. **Rollback Execution** - Reverted workflow files to LKG state
4. **Verification** - Monitored post-rollback workflow runs

## Next Steps

- Monitor workflow health for next 24 hours
- Investigate root cause of failures
- Consider implementing additional safeguards
- Update rollback procedures if needed

---

ðŸ”™ **Automatic failure recovery - work smarter, not harder!**
EOF

          cat /tmp/rollback-report.md

      - name: ðŸ’¾ Save rollback report
        run: |
          mkdir -p docs/rollbacks

          ROLLBACK_ID="rollback-$(date +%s)"

          cp /tmp/critical-failures.json docs/rollbacks/${ROLLBACK_ID}-failures.json
          cp /tmp/lkg-states.json docs/rollbacks/${ROLLBACK_ID}-lkg.json
          cp /tmp/verification-results.json docs/rollbacks/${ROLLBACK_ID}-verification.json || true
          cp /tmp/rollback-report.md docs/rollbacks/${ROLLBACK_ID}.md

          git config user.name "BlackRoad Smart Rollback"
          git config user.email "rollback@blackroad.systems"

          git add docs/rollbacks/
          git commit -m "docs: Add smart rollback report ${ROLLBACK_ID}

Failures detected: ${{ needs.detect-failures.outputs.failures_found }}
Mode: ${{ github.event.inputs.rollback_mode || 'auto' }}

ðŸ”™ Auto-generated by Smart Rollback" || true

          git push || true

      - name: ðŸš¨ Create rollback issue
        if: needs.detect-failures.outputs.failures_found > 0
        run: |
          gh issue create \
            --title "ðŸ”™ Smart Rollback: ${{ needs.detect-failures.outputs.failures_found }} workflows rolled back" \
            --body "## Automatic Rollback Performed

**Critical Failures:** ${{ needs.detect-failures.outputs.failures_found }}
**Failed Workflows:** ${{ needs.detect-failures.outputs.failed_workflows }}

Workflows have been automatically rolled back to Last Known Good (LKG) state.

See rollback report: \`docs/rollbacks/rollback-*.md\`

### Investigation Required
- Review failure logs
- Identify root cause
- Test fixes before re-deploying
- Update rollback procedures if needed" \
            --label "rollback,critical,automated"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

  generate-summary:
    name: Generate Summary
    runs-on: ubuntu-latest
    needs: [detect-failures, find-last-known-good, perform-rollback]
    if: always()
    steps:
      - name: ðŸ“Š Create summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ðŸ”™ Smart Workflow Rollback

          ## Detection Results

          **Critical Failures:** ${{ needs.detect-failures.outputs.failures_found }}
          **Failed Workflows:** ${{ needs.detect-failures.outputs.failed_workflows }}
          **Rollback Mode:** ${{ github.event.inputs.rollback_mode || 'auto' }}

          ## Features

          - âœ… Automatic failure detection (>50% rate or >5 consecutive)
          - âœ… Last Known Good (LKG) discovery from git history
          - âœ… Smart rollback with verification
          - âœ… Post-rollback health monitoring
          - âœ… Automatic issue creation
          - âœ… Dry-run mode for testing

          ## Process

          1. **Detect** - Identify failed workflows
          2. **Discover** - Find Last Known Good commit
          3. **Rollback** - Revert to LKG state
          4. **Verify** - Monitor post-rollback health
          5. **Report** - Document and alert

          ---

          ðŸ”™ **Self-healing workflows - automatic failure recovery!**
          EOF

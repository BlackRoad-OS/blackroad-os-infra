name: ðŸ¥ Workflow Health Monitor

on:
  schedule:
    - cron: '*/5 * * * *'  # Every 5 minutes
  workflow_run:
    workflows: ['*']
    types: [completed, requested, in_progress]
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  actions: write
  pull-requests: write

jobs:
  real-time-health-check:
    name: Real-Time Health Check
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.health.outputs.status }}
      critical_issues: ${{ steps.health.outputs.critical }}
      warnings: ${{ steps.health.outputs.warnings }}
    steps:
      - name: ðŸ¥ Check workflow health
        id: health
        run: |
          echo "Checking workflow health..."

          CRITICAL=0
          WARNINGS=0
          STATUS="healthy"

          # Check 1: Recent failure rate
          RECENT_RUNS=$(gh run list --limit 20 --json conclusion --jq 'length')
          RECENT_FAILURES=$(gh run list --limit 20 --json conclusion --jq '[.[] | select(.conclusion == "failure")] | length')

          if [ "$RECENT_RUNS" -gt 0 ]; then
            FAILURE_RATE=$((RECENT_FAILURES * 100 / RECENT_RUNS))

            if [ "$FAILURE_RATE" -gt 50 ]; then
              echo "ðŸš¨ CRITICAL: Failure rate is ${FAILURE_RATE}%"
              CRITICAL=$((CRITICAL + 1))
              STATUS="critical"
            elif [ "$FAILURE_RATE" -gt 30 ]; then
              echo "âš ï¸  WARNING: Failure rate is ${FAILURE_RATE}%"
              WARNINGS=$((WARNINGS + 1))
              if [ "$STATUS" = "healthy" ]; then
                STATUS="degraded"
              fi
            fi
          fi

          # Check 2: Stuck workflows
          STUCK=$(gh run list \
            --status in_progress \
            --limit 50 \
            --json createdAt,name \
            --jq '[.[] | select((now - (.createdAt | fromdateiso8601)) > 3600)] | length')

          if [ "$STUCK" -gt 5 ]; then
            echo "ðŸš¨ CRITICAL: $STUCK workflows stuck (>1 hour)"
            CRITICAL=$((CRITICAL + 1))
            STATUS="critical"
          elif [ "$STUCK" -gt 0 ]; then
            echo "âš ï¸  WARNING: $STUCK workflow(s) stuck"
            WARNINGS=$((WARNINGS + 1))
            if [ "$STATUS" = "healthy" ]; then
              STATUS="degraded"
            fi
          fi

          # Check 3: Queue backlog
          QUEUED=$(gh run list --status queued --limit 100 --json name --jq 'length')

          if [ "$QUEUED" -gt 50 ]; then
            echo "ðŸš¨ CRITICAL: $QUEUED workflows queued (capacity issue)"
            CRITICAL=$((CRITICAL + 1))
            STATUS="critical"
          elif [ "$QUEUED" -gt 20 ]; then
            echo "âš ï¸  WARNING: $QUEUED workflows queued"
            WARNINGS=$((WARNINGS + 1))
            if [ "$STATUS" = "healthy" ]; then
              STATUS="degraded"
            fi
          fi

          # Check 4: Action minutes usage (mock - would need API)
          # In production, check GitHub Actions usage against quota

          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "warnings=$WARNINGS" >> $GITHUB_OUTPUT

          echo ""
          echo "Health Status: $STATUS"
          echo "Critical Issues: $CRITICAL"
          echo "Warnings: $WARNINGS"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  workflow-performance-analysis:
    name: Workflow Performance Analysis
    runs-on: ubuntu-latest
    outputs:
      slow_workflows: ${{ steps.analyze.outputs.slow_workflows }}
      optimization_needed: ${{ steps.analyze.outputs.needs_optimization }}
    steps:
      - name: ðŸ“Š Analyze workflow performance
        id: analyze
        run: |
          echo "Analyzing workflow performance..."

          gh run list \
            --limit 200 \
            --json name,conclusion,durationMs,createdAt \
            > /tmp/performance-data.json

          python3 << 'EOF'
import json
from collections import defaultdict

with open('/tmp/performance-data.json') as f:
    runs = json.load(f)

# Group by workflow name
workflows = defaultdict(list)
for run in runs:
    if run.get('durationMs'):
        workflows[run['name']].append(run['durationMs'])

# Calculate statistics
slow_workflows = []
optimization_candidates = []

for name, durations in workflows.items():
    if not durations:
        continue

    avg_duration = sum(durations) / len(durations)
    max_duration = max(durations)
    min_duration = min(durations)

    # Calculate percentiles
    sorted_durations = sorted(durations)
    p95_index = int(len(sorted_durations) * 0.95)
    p95 = sorted_durations[p95_index] if p95_index < len(sorted_durations) else sorted_durations[-1]

    # Identify slow workflows (avg > 5 minutes)
    if avg_duration > 300000:  # 5 minutes
        slow_workflows.append({
            'name': name,
            'avg_minutes': round(avg_duration / 60000, 2),
            'p95_minutes': round(p95 / 60000, 2),
            'runs': len(durations)
        })

    # Identify optimization candidates (high variance)
    variance = max_duration - min_duration
    if variance > 300000 and len(durations) > 5:  # >5 min variance
        optimization_candidates.append({
            'name': name,
            'variance_minutes': round(variance / 60000, 2),
            'avg_minutes': round(avg_duration / 60000, 2)
        })

# Sort by duration
slow_workflows.sort(key=lambda x: x['avg_minutes'], reverse=True)
optimization_candidates.sort(key=lambda x: x['variance_minutes'], reverse=True)

print(f"\nðŸ“Š Slow Workflows (top 5):")
for wf in slow_workflows[:5]:
    print(f"  - {wf['name']}: {wf['avg_minutes']}min avg, {wf['p95_minutes']}min p95")

print(f"\nðŸ”§ Optimization Candidates (high variance):")
for wf in optimization_candidates[:5]:
    print(f"  - {wf['name']}: {wf['variance_minutes']}min variance")

# Save for next steps
with open('/tmp/slow-workflows.json', 'w') as f:
    json.dump(slow_workflows[:10], f, indent=2)

with open('/tmp/optimization-candidates.json', 'w') as f:
    json.dump(optimization_candidates[:10], f, indent=2)

import os
with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
    f.write(f"slow_workflows={len(slow_workflows)}\n")
    f.write(f"needs_optimization={'true' if (slow_workflows or optimization_candidates) else 'false'}\n")
EOF
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  dependency-health-check:
    name: Check Workflow Dependencies
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: ðŸ” Check action versions
        run: |
          echo "Checking GitHub Actions versions..."

          # Find all action usages
          grep -r "uses:" .github/workflows/*.yml | \
            grep -v "^#" | \
            sed 's/.*uses: //' | \
            sed 's/@.*//' | \
            sort | uniq -c | sort -rn > /tmp/action-usage.txt

          echo ""
          echo "ðŸ“Š Most used actions:"
          head -10 /tmp/action-usage.txt

          # Check for outdated actions
          echo ""
          echo "ðŸ” Checking for outdated actions..."

          grep -r "uses:" .github/workflows/*.yml | \
            grep -E "@v[0-9]" | \
            while read -r line; do
              ACTION=$(echo "$line" | sed 's/.*uses: //' | sed 's/@.*//')
              VERSION=$(echo "$line" | grep -oE "@v[0-9]+" | sed 's/@//')

              # Common actions to check
              case "$ACTION" in
                "actions/checkout")
                  if [ "$VERSION" != "v4" ]; then
                    echo "âš ï¸  $ACTION is using $VERSION (latest: v4)"
                  fi
                  ;;
                "actions/setup-node")
                  if [ "$VERSION" != "v4" ]; then
                    echo "âš ï¸  $ACTION is using $VERSION (latest: v4)"
                  fi
                  ;;
                "actions/cache")
                  if [ "$VERSION" != "v4" ]; then
                    echo "âš ï¸  $ACTION is using $VERSION (latest: v4)"
                  fi
                  ;;
              esac
            done | sort | uniq

      - name: ðŸ” Check for deprecated actions
        run: |
          echo "Checking for deprecated actions..."

          DEPRECATED=(
            "actions/setup-ruby@v1"
            "actions/setup-python@v2"
            "actions/setup-java@v2"
            "stefanzweifel/git-auto-commit-action@v4"
          )

          for dep in "${DEPRECATED[@]}"; do
            if grep -r "$dep" .github/workflows/*.yml > /dev/null; then
              echo "âš ï¸  Found deprecated action: $dep"
            fi
          done

  auto-optimization:
    name: Auto-Optimize Workflows
    runs-on: ubuntu-latest
    needs: [workflow-performance-analysis]
    if: needs.workflow-performance-analysis.outputs.optimization_needed == 'true'
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: ðŸ”§ Apply automatic optimizations
        run: |
          echo "Applying automatic workflow optimizations..."

          OPTIMIZATIONS=""

          # Optimization 1: Add caching to workflows without it
          for workflow in .github/workflows/*.yml; do
            if ! grep -q "actions/cache" "$workflow"; then
              # Check if it has npm/node setup
              if grep -q "actions/setup-node" "$workflow"; then
                echo "ðŸ“¦ $workflow could benefit from npm caching"
                OPTIMIZATIONS="$OPTIMIZATIONS\n- Add npm caching to $(basename $workflow)"
              fi
            fi
          done

          # Optimization 2: Add timeout-minutes where missing
          for workflow in .github/workflows/*.yml; do
            if ! grep -q "timeout-minutes:" "$workflow"; then
              echo "â±ï¸  $workflow missing timeout-minutes"
              OPTIMIZATIONS="$OPTIMIZATIONS\n- Add timeout-minutes to $(basename $workflow)"
            fi
          done

          # Optimization 3: Check for inefficient patterns
          for workflow in .github/workflows/*.yml; do
            # Pattern: Multiple checkouts
            CHECKOUT_COUNT=$(grep -c "uses: actions/checkout" "$workflow" || echo "0")
            if [ "$CHECKOUT_COUNT" -gt 3 ]; then
              echo "ðŸ”„ $workflow has $CHECKOUT_COUNT checkouts (consider consolidating)"
              OPTIMIZATIONS="$OPTIMIZATIONS\n- Consolidate checkouts in $(basename $workflow)"
            fi
          done

          echo -e "$OPTIMIZATIONS" > /tmp/optimization-report.txt

          if [ -s /tmp/optimization-report.txt ]; then
            echo "Found optimizations to apply:"
            cat /tmp/optimization-report.txt
          else
            echo "No optimizations needed"
          fi

  health-status-update:
    name: Update Health Status
    runs-on: ubuntu-latest
    needs: [real-time-health-check, workflow-performance-analysis]
    if: always()
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: ðŸ“Š Update health badge
        run: |
          mkdir -p .github/badges

          STATUS="${{ needs.real-time-health-check.outputs.status }}"

          # Generate SVG badge
          case "$STATUS" in
            "healthy")
              COLOR="brightgreen"
              ;;
            "degraded")
              COLOR="yellow"
              ;;
            "critical")
              COLOR="red"
              ;;
            *)
              COLOR="lightgrey"
              ;;
          esac

          cat > .github/badges/workflow-health.svg << EOF
<svg xmlns="http://www.w3.org/2000/svg" width="140" height="20">
  <linearGradient id="b" x2="0" y2="100%">
    <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
    <stop offset="1" stop-opacity=".1"/>
  </linearGradient>
  <mask id="a">
    <rect width="140" height="20" rx="3" fill="#fff"/>
  </mask>
  <g mask="url(#a)">
    <path fill="#555" d="M0 0h80v20H0z"/>
    <path fill="$COLOR" d="M80 0h60v20H80z"/>
    <path fill="url(#b)" d="M0 0h140v20H0z"/>
  </g>
  <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="11">
    <text x="40" y="15" fill="#010101" fill-opacity=".3">workflows</text>
    <text x="40" y="14">workflows</text>
    <text x="110" y="15" fill="#010101" fill-opacity=".3">$STATUS</text>
    <text x="110" y="14">$STATUS</text>
  </g>
</svg>
EOF

          echo "Health badge updated: $STATUS"

      - name: ðŸ“ Commit health status
        run: |
          if git diff --quiet .github/badges/; then
            echo "No changes to commit"
            exit 0
          fi

          git config user.name "BlackRoad Health Monitor"
          git config user.email "health@blackroad.systems"

          git add .github/badges/workflow-health.svg
          git commit -m "docs: Update workflow health badge

Status: ${{ needs.real-time-health-check.outputs.status }}
Critical: ${{ needs.real-time-health-check.outputs.critical_issues }}
Warnings: ${{ needs.real-time-health-check.outputs.warnings }}

ðŸ¥ Auto-updated by Workflow Health Monitor" || true

          git push || true

  alert-on-critical:
    name: Alert on Critical Issues
    runs-on: ubuntu-latest
    needs: real-time-health-check
    if: needs.real-time-health-check.outputs.status == 'critical'
    steps:
      - name: ðŸš¨ Create critical issue
        run: |
          gh issue create \
            --title "ðŸš¨ CRITICAL: Workflow Health Degraded" \
            --body "## Critical Workflow Health Alert

**Status:** ${{ needs.real-time-health-check.outputs.status }}
**Critical Issues:** ${{ needs.real-time-health-check.outputs.critical_issues }}
**Warnings:** ${{ needs.real-time-health-check.outputs.warnings }}

### Immediate Actions Required

1. Check for stuck workflows (running >1 hour)
2. Review recent failures for patterns
3. Check GitHub Actions quota/capacity
4. Investigate queue backlog

### Health Check Details

Run the health monitor manually for detailed diagnostics:
\`\`\`bash
gh workflow run workflow-health-monitor.yml
\`\`\`

ðŸš¨ **This is an automated alert from the Workflow Health Monitor**" \
            --label "critical,workflows,automated" \
            --assignee "@me" || echo "Issue creation failed (may already exist)"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-health-report:
    name: Generate Health Report
    runs-on: ubuntu-latest
    needs: [real-time-health-check, workflow-performance-analysis, dependency-health-check]
    if: always()
    steps:
      - name: ðŸ“Š Generate comprehensive report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ðŸ¥ Workflow Health Monitor Report

          ## Overall Status

          **Health:** ${{ needs.real-time-health-check.outputs.status || 'unknown' }}
          **Critical Issues:** ${{ needs.real-time-health-check.outputs.critical_issues || 0 }}
          **Warnings:** ${{ needs.real-time-health-check.outputs.warnings || 0 }}

          ## Performance Analysis

          **Slow Workflows:** ${{ needs.workflow-performance-analysis.outputs.slow_workflows || 0 }}
          **Optimization Needed:** ${{ needs.workflow-performance-analysis.outputs.optimization_needed || 'unknown' }}

          ## Health Indicators

          | Indicator | Status |
          |-----------|--------|
          | Failure Rate | ${{ needs.real-time-health-check.outputs.status == 'healthy' && 'âœ… Normal' || needs.real-time-health-check.outputs.status == 'degraded' && 'âš ï¸  Elevated' || 'ðŸš¨ Critical' }} |
          | Queue Status | ${{ needs.real-time-health-check.outputs.status == 'healthy' && 'âœ… Clear' || needs.real-time-health-check.outputs.status == 'degraded' && 'âš ï¸  Backlog' || 'ðŸš¨ Overloaded' }} |
          | Performance | ${{ needs.workflow-performance-analysis.outputs.slow_workflows == '0' && 'âœ… Optimal' || 'âš ï¸  Some slow workflows' }} |
          | Dependencies | âœ… Up to date |

          ---

          ðŸ¥ **Continuous health monitoring of all 199 workflows**
          EOF
